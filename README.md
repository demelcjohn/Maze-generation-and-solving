# Maze Generation and Solving

Design and implement an algorithm to generate a random maze and then solve it. The maze
will be represented as a grid of cells, where each cell can either be a wall or a passage. The goal
of the algorithm is to create a maze with a single entrance and a single exit, ensuring that there
is a path between any two cells in the maze. Additionally, the algorithm should be able to find
a solution from the entrance to the exit.

Design and implement an algorithm to generate a random maze using the following require-
ments:

(a) Maze Generation:
i. The maze should have a user-defined size (number of rows and columns).
ii. The maze should have a clear entrance and exit point, located at the top-left and bottom-right
corners respectively.
iii. There should be a path connecting the entrance and exit points, and every cell in the maze
should be reachable from the entrance.
iv. The maze should have a reasonable level of complexity, with dead-ends and twists in the
paths.

v. The algorithm should be efficient, avoiding excessive backtracking or unneces- sary computa-
tions.

(b) Maze Solving:
i. Implement an algorithm to solve the generated maze and find a path from the entrance to the
exit.
ii. You can choose a pathfinding algorithm, such as Breadth-First Search (BFS) or Depth-First
Search (DFS), to find the solution.
iii. The solution path should be stored and presented as a sequence of cells or coordinates.

Write a detailed algorithm description that outlines the steps involved in both maze genera-
tion and maze solving. Include the data structures, such as arrays or graphs, that will be used

to represent the maze and track the progress of the algorithms. Analyze the time and space
complexity of your algorithms, and discuss any trade-offs or optimizations that can be made.

In addition to the algorithm description, provide a working implementation of the maze genera-
tion and solving algorithms in a programming language of your choice.

Test the algorithms by generating and solving mazes of various sizes, and visually represent
them using appropriate symbols.
Submit your algorithm description, implementation code, and a report discussing the efficiency,
performance, and any challenges encountered during the implementation process.
